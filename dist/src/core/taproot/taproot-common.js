"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.G = exports.bitcoinjslibNetworks = exports.SECP256K1_ORDER = exports.taprootVersion = void 0;
exports.getHash = getHash;
exports.combineHashes = combineHashes;
exports.compactSize = compactSize;
const crypto_1 = require("bitcoinjs-lib/src/crypto");
const encoding_1 = require("./encoding");
const bitcoin = __importStar(require("bitcoinjs-lib"));
exports.taprootVersion = 0xc0;
// Order of the base point (n) for SECP256K1
// The number of points generated by G is n, which is a prime number.
exports.SECP256K1_ORDER = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
exports.bitcoinjslibNetworks = {
    regtest: bitcoin.networks.regtest,
    testnet: bitcoin.networks.testnet,
    mainnet: bitcoin.networks.bitcoin,
};
// Base point (G) coordinates for SECP256K1
// G is the generator point on the curve, defined as (x, y):
exports.G = {
    x: 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,
    y: 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n,
};
function getHash(script) {
    const cs = compactSize(script.length);
    const data = (0, encoding_1.cat)([Buffer.from([exports.taprootVersion]), cs, script]);
    const h = (0, crypto_1.taggedHash)('TapLeaf', data);
    return h;
}
function combineHashes(left_h, right_h) {
    const t = right_h.compare(left_h);
    if (t === -1) {
        [left_h, right_h] = [right_h, left_h];
    }
    return (0, crypto_1.taggedHash)('TapBranch', Buffer.concat([left_h, right_h]));
}
function compactSize(l) {
    if (l <= 252)
        return Buffer.from([l]);
    if (l > 252 && l <= 65535)
        return Buffer.from([0xfd, l & 0xff, l >> 8]);
    if (l > 65535 && l <= 4294967295)
        return Buffer.from([
            0xfe,
            l & 0xff,
            (l >> 8) & 0xff,
            (l >> 16) & 0xff,
            (l >> 24) & 0xff,
        ]);
    throw new Error('Too big');
}
